from src.model.relation import Relation
from src.model.attribute import AttributeInfo, AttributeTypes
from src.instantiation.dbinstance import DBInstance
from src.utils.utilfunctions import write_db_inst
from random import randint

if __name__ == "__main__":
    # Table UnifMembers contains all student/professors and info on each ppl, uniquely identified by a given matricule

    # This matricule is automatically generated as an integer incrementing (AttributeTypes.incr_int does it by default)
    matricule = AttributeInfo("matricule", attr_type=AttributeTypes.incr_int,
                              desc="Registration number in university system")
    # A random string value will be generated by default with AttributeTypes.str
    persID = AttributeInfo("persid", attr_type=AttributeTypes.str,
                           desc="A personal identifier settable by the member (rdm initially)")

    # Definition of a generation constraint on faculty attribute whose values should belongs to a predefined set
    EXISTING_FACS = ["sciences", "EII", "SHS", "FPSE", "FMM"]

    def get_rdm_fac(_):
        return EXISTING_FACS[randint(0, len(EXISTING_FACS)-1)]
    fac = AttributeInfo("faculty", attr_type=AttributeTypes.str, get_generator_fun=lambda _: get_rdm_fac,
                        desc="Faculty a univ member is associated with among existing ones (not regarding uni site)")

    # Definition of a generation constraint on 'role' attribute value, which should depend on another attribute of the
    # same table : matricule. This is similar to a function dependency, but stronger because values are explicit.
    # Let's say all uni members whose matricule integer value is multiple of 10 are professor, else student.
    def get_role(given_others_attr_values):
        # the parameter should contain, for a tuple, the already generated value for matricule attribute
        matricule_value = int(given_others_attr_values["matricule"])
        is_prof = (matricule_value % 10 == 0)
        return "professor" if is_prof else "student"
    # As the role is defined from the matricule, impose a generation order > than matricule's one (that is 1 by default)
    role = AttributeInfo("role", attr_type=AttributeTypes.str, get_generator_fun=lambda _: get_role, gen_order=2,
                         desc="Role of the member in the university (professor/student)")

    # Build the relation model from the instantiated attributes
    univ = Relation("UnivMembers", attributes=[matricule, persID, fac, role], pk=matricule)

    # Table Faculties gives info about in which city the faculty has an implementation

    # PK of Faculties is 2-attr composed as a faculty may have multiple instances in different cities
    fac_in_pk = fac.__copy__()
    fac_in_pk.desc = "An UMONS faculty"

    def get_city(_):
        # By default, all faculties have one instance in Mons. Others should be explicitly generated with the
        # corresponding city specified
        return "Mons"
    city = AttributeInfo("city", attr_type=AttributeTypes.str, get_generator_fun=lambda _: get_city,
                         desc="Place where an UMONS faculty is present")

    # For each faculty present in a city, a label is generated to use it as a shortcut in courses schedules
    def get_label(given_others_attr_values):
        # Label is formed from the couple faculty + city that is the faculty site
        return given_others_attr_values["city"] + '-' + given_others_attr_values["faculty"]
    label = AttributeInfo("sitelabel", attr_type='str', get_generator_fun=lambda _: get_label,
                          desc="Label used as a shortcut designing the site of a faculty")
    faculties = Relation("Faculties", attributes=[fac_in_pk, city, label], pk=[fac_in_pk, city])

    # Table UsedSites references all labels defined and usable by the scheduling application used by uni members

    # An attribute can have a local name (shortcut), but his usage in a relational model can be overwritten to respect
    # FK constraints (here 'sitelabel' from Faculties will be a FK referencing UsedSites, so renaming at relation level
    # is needed)

    shortcut = AttributeInfo("shortcut", attr_type='str', desc="Usable shortcut in a scheduling application")
    usedsites = Relation("UsedSites", attributes={"sitelabel": shortcut}, pk="sitelabel")

    # After relations definitions, adding FK constraints between tables
    univ.add_fk_constraint({"faculty": faculties})
    faculties.add_fk_constraint({"sitelabel": usedsites})

    print("Relational models defined :\n", univ, faculties, usedsites, sep='\n')

    # Time to generate some tuples instantiating the whole database from relational model, with diff parameters

    # As UnivMembers has FK-> Faculties and Faculties has FK-> UsedSites, generating tuples only in UnivMembers should
    # though lead tuples generation in Faculties and after UsedSites to respect FKs (the process is iterative, firstly
    # generate tuples in Faculties from 'faculty' values in UnivMembers, that further generate tuples in UsedSites from
    # 'sitelabel' values in Faculties).
    rel_inst_params1 = {univ: 15, faculties: 0, usedsites: 0}

    # Declaring explicitly myself to uni members, knowing my matricule and a professor whose matricule is unknown
    # Adding a site for sciences faculty in Charleroi that will generate a new label
    # The parametrisation of relations instantiations is very flexible
    rel_inst_params2 = {univ: [10,
                               (1, {"matricule": 160367, "persid": "remdec", "faculty": "sciences", "role": "student"}),
                               {"persid": "myprof", "faculty": "sciences", "role": "professor"}
                               ],
                        faculties: {"faculty": "sciences", "city": "Charleroi"},
                        usedsites: 0
                        }

    rel_inst_params = rel_inst_params1
    db = DBInstance(rel_inst_params)
    print(db)

    # Create a big database and write it in an ASP-compliant format to query on it via logical programming
    rel_big_inst_params = {univ: 500000, faculties: 0, usedsites: 0}
    write_db_inst(DBInstance(rel_big_inst_params), asp=True, printed=False, target_dir="../../outputs")
